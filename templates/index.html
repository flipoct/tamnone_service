<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>TeamCMD</title>

  <style>
    body{
      font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,Arial,sans-serif;
      background:#f0f2f5;
      margin:0;
      padding:24px;
    }
    .container{
      max-width:1100px;
      margin:0 auto;
      background:#fff;
      padding:20px;
      border-radius:12px;
      box-shadow:0 4px 12px rgba(0,0,0,.1);
    }
    h1{margin:0 0 12px 0;}

    .grid{
      display:grid;
      grid-template-columns:1.1fr .9fr;
      gap:14px;
    }
    @media (max-width: 980px){
      .grid{grid-template-columns:1fr;}
    }

    .card{
      border:1px solid #e9ecef;
      border-radius:10px;
      background:#fff;
    }
    .card h2{
      margin:0;
      padding:12px;
      font-size:15px;
      border-bottom:1px solid #eee;
      background:#fafafa;
    }
    .body{padding:12px;}

    textarea{
      width:100%;
      height:280px;
      padding:12px;
      font-size:14px;
      line-height:1.55;
      border-radius:8px;
      border:1px solid #ccc;
      resize:vertical;
      box-sizing:border-box;
      white-space:pre-wrap;
    }

    .row{
      display:flex;
      gap:10px;
      margin-top:10px;
      flex-wrap:wrap;
    }
    button{
      padding:10px 12px;
      border:none;
      border-radius:8px;
      font-weight:700;
      cursor:pointer;
      background:#6c757d;
      color:#fff;
    }
    button:hover{filter:brightness(.95);}

    .alert{
      margin-top:12px;
      padding:12px;
      border-radius:8px;
      border:1px solid #ddd;
      background:#f8f9fa;
    }
    .alert.good{background:#e8f5e9;border-color:#a5d6a7;}
    .alert.warn{background:#fff3e0;border-color:#ffcc80;}
    .alert.danger{background:#ffebee;border-color:#ef9a9a;}

    .badge{
      display:inline-block;
      padding:4px 10px;
      border-radius:999px;
      font-size:12px;
      font-weight:800;
      color:#fff;
      background:#777;
      vertical-align:middle;
    }
    .badge.good{background:#2e7d32;}
    .badge.warn{background:#ef6c00;}
    .badge.danger{background:#c62828;}

    pre{
      background:#f8f9fa;
      border:1px solid #ddd;
      border-radius:8px;
      padding:12px;
      max-height:420px;
      overflow:auto;
      font-size:13.5px;
      line-height:1.6;
      margin:0;
      white-space:pre-wrap;
      word-break:break-word;
    }

    canvas{
      width:100%;
      height:240px;
      border:1px solid #ddd;
      border-radius:8px;
      display:block;
      background:#fff;
    }

    .chip{
      padding:6px 10px;
      border-radius:999px;
      border:1px solid #ddd;
      font-size:12px;
      cursor:pointer;
      font-weight:800;
      user-select:none;
      background:#fff;
    }
    .chip.active{
      background:#111;
      color:#fff;
      border-color:#111;
    }

    .legend{
      display:flex;
      flex-wrap:wrap;
      gap:10px;
      margin-top:10px;
    }
    .legend-item{
      display:flex;
      align-items:center;
      gap:6px;
      font-size:12px;
    }
    .swatch{
      width:12px;height:12px;border-radius:3px;
      border:1px solid rgba(0,0,0,.2);
    }
  </style>
</head>

<body>
  <div class="container">
    <h1>TeamCMD</h1>

    <div class="grid">
      <div class="card">
        <h2>대화 입력 (Enter = 분석, Shift+Enter = 줄바꿈)</h2>
        <div class="body">
          <textarea id="text-input" placeholder="예시(둘 다 가능)
[화자1] 안녕?
화자2: 안녕!"></textarea>

          <div class="row">
            <button id="reset-btn" type="button">새 대화 시작</button>
          </div>

          <div class="alert" id="conflict-alert">
            <b id="alert-title">갈등 가능성: 대기</b>
            <span class="badge" id="alert-badge">대기</span>
            <div id="alert-detail" style="margin-top:6px;"></div>
          </div>
        </div>
      </div>

      <div class="card">
        <h2>감정 변화 그래프 (화자별 보기)</h2>
        <div class="body">
          <div id="speaker-buttons" style="display:flex;gap:8px;flex-wrap:wrap;margin-bottom:10px;"></div>
          <canvas id="trend-canvas" width="900" height="360"></canvas>
          <div class="legend" id="legend"></div>
        </div>
      </div>
    </div>

    <div class="card" style="margin-top:14px;">
      <h2>분석 결과 (각 발화별 감정 Top 3)</h2>
      <div class="body">
        <pre id="results-output">분석 대기 중...</pre>
      </div>
    </div>
  </div>

  <script>
  document.addEventListener('DOMContentLoaded', function () {
    const textarea = document.getElementById('text-input');
    const output = document.getElementById('results-output');

    const alertBox = document.getElementById('conflict-alert');
    const alertTitle = document.getElementById('alert-title');
    const alertBadge = document.getElementById('alert-badge');
    const alertDetail = document.getElementById('alert-detail');

    const resetBtn = document.getElementById('reset-btn');

    const speakerBtns = document.getElementById('speaker-buttons');
    const legend = document.getElementById('legend');
    const canvas = document.getElementById('trend-canvas');
    const ctx = canvas.getContext('2d');

    const COLORS = [
      '#1f77b4','#ff7f0e','#2ca02c','#d62728','#9467bd',
      '#8c564b','#e377c2','#7f7f7f','#bcbd22','#17becf',
      '#2f4b7c','#f95d6a','#ffa600'
    ];

    let lastResult = null;
    let selectedSpeaker = null;

    function getApiBase() {
      // 파일로 열면 origin이 "null"일 수 있음 → 로컬 서버로 fallback
      if (!window.location.origin || window.location.origin === 'null') {
        return 'http://127.0.0.1:5000';
      }
      return window.location.origin;
    }

    function normalizeSpeakerLabel(s) {
      let out = (s == null ? '' : String(s)).trim();
      if (!out) return 'Speaker';
      // 서버 결과가 "[Speaker1]" 이런 형태일 때 괄호 제거
      if (out.startsWith('[') && out.endsWith(']') && out.length >= 2) {
        out = out.slice(1, -1).trim();
      }
      return out || 'Speaker';
    }

    // 입력 한 줄 파싱:
    // 1) [화자] 내용  -> speaker="화자", text="내용"
    // 2) 화자: 내용   -> speaker="화자", text="내용"
    // 3) 그 외        -> speaker="Manual", text=원문
    function parseLineToSpeakerText(line) {
      let content = (line || '').trim();
      if (!content) return null;

      let speaker = 'Manual';

      const mBracket = content.match(/^\[([^\]]+)\]\s*(.*)$/);
      if (mBracket) {
        speaker = (mBracket[1] || '').trim() || 'Manual';
        content = (mBracket[2] || '').trim();
        return { speaker: speaker, text: content };
      }

      const mColon = content.match(/^([^:]{1,40})\s*:\s*(.*)$/);
      if (mColon) {
        speaker = (mColon[1] || '').trim() || 'Manual';
        content = (mColon[2] || '').trim();
        return { speaker: speaker, text: content };
      }

      return { speaker: speaker, text: content };
    }

    // textarea 전체를 lines[]로 변환 (서버 /analyze_snapshot 입력 형식)
    function parseTextareaToLines(text) {
      const raw = String(text || '');
      const rows = raw.split('\n');
      const out = [];
      for (let i = 0; i < rows.length; i++) {
        const parsed = parseLineToSpeakerText(rows[i]);
        if (!parsed) continue;
        if (!parsed.text || !parsed.text.trim()) continue;
        out.push({ speaker: normalizeSpeakerLabel(parsed.speaker), text: parsed.text.trim() });
      }
      return out;
    }

    function topNEmotions(emoObj, n) {
      const entries = Object.entries(emoObj || {});
      entries.sort((a,b) => (b[1]||0) - (a[1]||0));
      return entries.slice(0, n);
    }

    function renderSummary(result) {
      const logs = (result && result.per_utt_log) ? result.per_utt_log : [];
      if (!logs.length) {
        output.textContent = '분석 결과 없음';
        return;
      }

      let text = '';
      for (let i = 0; i < logs.length; i++) {
        const l = logs[i];
        const sp = normalizeSpeakerLabel(l.speaker);
        const utt = (l.text || '').toString();

        text += `화자 ${sp}\n`;
        text += `발화: ${utt}\n`;
        text += `주요 감정(Top 3):\n`;

        const top3 = topNEmotions(l.negative_emotions || {}, 3);
        if (!top3.length) {
          text += '  - (감정 정보 없음)\n\n';
          continue;
        }
        for (let j = 0; j < top3.length; j++) {
          const k = top3[j][0];
          const v = Number(top3[j][1] || 0);
          text += `  - ${k}: ${v.toFixed(1)}%\n`;
        }
        text += '\n';
      }

      output.textContent = text;
    }

    function updateConflict(result) {
      const fa = (result && result.future_alerts) ? result.future_alerts : {};
      const keys = Object.keys(fa || {});
      const alerts = [];
      for (let i = 0; i < keys.length; i++) {
        const k = keys[i];
        const arr = fa[k];
        if (Array.isArray(arr)) {
          for (let j = 0; j < arr.length; j++) alerts.push({ speaker: k, msg: arr[j] });
        }
      }

      alertBox.className = 'alert';
      alertBadge.className = 'badge';
      alertDetail.textContent = '';

      if (!alerts.length) {
        alertBox.classList.add('good');
        alertBadge.classList.add('good');
        alertBadge.textContent = '낮음';
        alertTitle.textContent = '갈등 가능성: 낮음';
        return;
      }

      // 알림이 있으면 '주의'로 표시 (요구대로 "반환값 기준")
      alertBox.classList.add('danger');
      alertBadge.classList.add('danger');
      alertBadge.textContent = '주의';
      alertTitle.textContent = '갈등 가능성: 높음';

      // 상세: speaker별 메시지 간단 표시
      const bySp = {};
      for (let i = 0; i < alerts.length; i++) {
        const sp = normalizeSpeakerLabel(alerts[i].speaker);
        if (!bySp[sp]) bySp[sp] = [];
        bySp[sp].push(String(alerts[i].msg || ''));
      }
      const lines = [];
      Object.keys(bySp).forEach(function (sp) {
        const msgs = bySp[sp].slice(0, 3);
        lines.push(sp + ': ' + msgs.join(' / '));
      });
      alertDetail.textContent = lines.join(' | ');
    }

    function drawGraph() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      speakerBtns.innerHTML = '';
      legend.innerHTML = '';

      const log = (lastResult && lastResult.per_utt_log) ? lastResult.per_utt_log : [];
      if (!log.length) return;

      const speakers = Array.from(new Set(log.map(x => normalizeSpeakerLabel(x.speaker))));
      if (!speakers.length) return;

      if (!selectedSpeaker || speakers.indexOf(selectedSpeaker) === -1) {
        selectedSpeaker = speakers[0];
      }

      // speaker buttons
      speakers.forEach(function (s) {
        const b = document.createElement('div');
        b.className = 'chip' + (s === selectedSpeaker ? ' active' : '');
        b.textContent = s;
        b.onclick = function () {
          selectedSpeaker = s;
          drawGraph();
        };
        speakerBtns.appendChild(b);
      });

      const data = log.filter(x => normalizeSpeakerLabel(x.speaker) === selectedSpeaker);
      if (data.length < 2) return;

      // 감정 종류: (가장 마지막 발화의 emotion key 기준) 너무 많으면 8개까지만
      const lastEmo = data[data.length - 1].negative_emotions || {};
      const emotionKeys = Object.keys(lastEmo);
      // 많이 그리면 난잡해지니, 평균값 상위 8개로 제한
      const avgMap = {};
      for (let i = 0; i < data.length; i++) {
        const eobj = data[i].negative_emotions || {};
        Object.keys(eobj).forEach(function (k) {
          const v = Number(eobj[k] || 0);
          avgMap[k] = (avgMap[k] || 0) + v;
        });
      }
      const ranked = Object.entries(avgMap).sort((a,b)=>b[1]-a[1]).slice(0, 8).map(x=>x[0]);

      const emotions = ranked.length ? ranked : emotionKeys.slice(0, 8);
      if (!emotions.length) return;

      // axes
      const left = 56, right = 20, top = 18, bottom = 48;
      const W = canvas.width, H = canvas.height;
      const x0 = left, y0 = H - bottom;
      const x1 = W - right, y1 = top;

      ctx.lineWidth = 1;
      ctx.strokeStyle = '#444';
      ctx.beginPath();
      ctx.moveTo(x0, y1);
      ctx.lineTo(x0, y0);
      ctx.lineTo(x1, y0);
      ctx.stroke();

      // y grid (0~100)
      ctx.strokeStyle = '#ddd';
      ctx.fillStyle = '#666';
      ctx.font = '12px sans-serif';
      for (let t = 0; t <= 100; t += 20) {
        const yy = y0 - (t/100) * (y0 - y1);
        ctx.beginPath();
        ctx.moveTo(x0, yy);
        ctx.lineTo(x1, yy);
        ctx.stroke();
        ctx.fillText(String(t), 20, yy + 4);
      }

      // x labels (index)
      ctx.fillStyle = '#666';
      const n = data.length;
      for (let i = 0; i < n; i++) {
        if (n > 10 && i % 2 === 1) continue;
        const xx = x0 + (i/(n-1))*(x1-x0);
        ctx.fillText(String(i+1), xx - 3, y0 + 18);
      }
      ctx.fillText('turn', x1 - 28, y0 + 34);

      // lines
      emotions.forEach(function (emo, idx) {
        const color = COLORS[idx % COLORS.length];

        ctx.beginPath();
        for (let i = 0; i < n; i++) {
          const eobj = data[i].negative_emotions || {};
          const v = Number(eobj[emo] || 0);
          const xx = x0 + (i/(n-1))*(x1-x0);
          const yy = y0 - (v/100)*(y0-y1);
          if (i === 0) ctx.moveTo(xx, yy);
          else ctx.lineTo(xx, yy);
        }
        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        ctx.stroke();

        // legend
        const li = document.createElement('div');
        li.className = 'legend-item';
        li.innerHTML = '<div class="swatch" style="background:'+color+'"></div>' + emo;
        legend.appendChild(li);
      });
    }

    async function analyze() {
      const api = getApiBase();
      const lines = parseTextareaToLines(textarea.value);

      if (!lines.length) {
        output.textContent = '입력된 발화가 없습니다.';
        return;
      }

      output.textContent = '분석 중...';

      let res, json;
      try {
        res = await fetch(api + '/analyze_snapshot', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ lines: lines })
        });
        json = await res.json();
      } catch (e) {
        output.textContent = '요청 실패: ' + String(e && e.message ? e.message : e);
        return;
      }

      console.log('[FULL ANALYSIS JSON]', json);

      if (!res.ok || json.error) {
        output.textContent = '오류: ' + (json.error || ('HTTP ' + res.status));
        return;
      }

      lastResult = json.result;
      renderSummary(lastResult);
      updateConflict(lastResult);
      drawGraph();
    }

    textarea.addEventListener('keydown', async function (e) {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        await analyze();
      }
    });

    resetBtn.addEventListener('click', async function () {
      const api = getApiBase();
      try {
        await fetch(api + '/reset', { method: 'POST' });
      } catch (_) {}
      textarea.value = '';
      output.textContent = '분석 대기 중...';
      lastResult = null;
      selectedSpeaker = null;
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      speakerBtns.innerHTML = '';
      legend.innerHTML = '';
      alertBox.className = 'alert';
      alertBadge.className = 'badge';
      alertBadge.textContent = '대기';
      alertTitle.textContent = '갈등 가능성: 대기';
      alertDetail.textContent = '';
    });

  });
  </script>
</body>
</html>
