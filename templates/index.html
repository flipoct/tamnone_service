<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>TeamCMD</title>
  <style>
    body{
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Noto Sans KR", Arial, sans-serif;
      margin: 0;
      padding: 0;
      background: #f6f7f9;
      color:#111;
    }
    .container{
      max-width: 1100px;
      margin: 0 auto;
      padding: 18px 14px 40px;
    }
    header{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      margin-bottom:10px;
    }
    header h1{
      margin:0;
      font-size: 22px;
      letter-spacing: -0.2px;
    }

    .grid{
      display:grid;
      grid-template-columns: 1.05fr 1.45fr;
      gap:14px;
    }
    @media (max-width: 960px){
      .grid{ grid-template-columns: 1fr; }
    }

    .card{
      background:#fff;
      border:1px solid #e9ecef;
      border-radius: 12px;
      box-shadow: 0 1px 0 rgba(0,0,0,0.02);
      overflow:hidden;
    }
    .card h2{
      margin:0;
      padding: 14px 14px 10px;
      font-size: 14px;
      font-weight: 900;
      border-bottom: 1px solid #f1f3f5;
    }
    .card .body{
      padding: 14px;
    }

    textarea{
      width:100%;
      height: 240px;
      resize: vertical;
      padding: 12px;
      border-radius: 10px;
      border:1px solid #e9ecef;
      outline:none;
      font-size: 13px;
      line-height: 1.55;
      background:#fbfbfc;
      box-sizing:border-box;
    }
    textarea:focus{
      border-color:#111;
      background:#fff;
    }

    pre{
      margin:0;
      background:#0b1020;
      color:#e8eaf6;
      padding: 12px;
      border-radius: 10px;
      overflow:auto;
      min-height: 220px;
      font-size: 12px;
      line-height: 1.6;
      box-sizing:border-box;
      white-space: pre-wrap;
      word-break: break-word;
    }

    .btn-row{
      display:flex;
      gap:8px;
      margin-top:10px;
      flex-wrap:wrap;
    }
    button.action{
      border:1px solid #111;
      background:#111;
      color:#fff;
      padding: 9px 12px;
      border-radius: 10px;
      font-size: 13px;
      font-weight: 800;
      cursor:pointer;
    }
    button.action.secondary{
      border:1px solid #ddd;
      background:#fff;
      color:#111;
    }
    button.action:active{ transform: translateY(1px); }

    .statusline{
      margin: 0 0 14px 0;
      padding: 10px 12px;
      border-radius: 10px;
      border: 1px solid #e9ecef;
      background:#f8f9fa;
      color:#333;
      font-size: 13px;
      line-height: 1.4;
    }
    .statusline.ok{ border-color:#c8e6c9; background:#e8f5e9; }
    .statusline.bad{ border-color:#ffcdd2; background:#ffebee; }

    .alert{
      margin-top: 12px;
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:12px;
      border-radius: 12px;
      padding: 12px;
      border: 1px solid #e9ecef;
      background:#fafafa;
    }
    .alert.good{ border-color:#c8e6c9; background:#e8f5e9; }
    .alert.warn{ border-color:#ffe0b2; background:#fff3e0; }
    .alert.danger{ border-color:#ffcdd2; background:#ffebee; }
    .alert .title{
      font-weight: 900;
      font-size: 13px;
      margin-bottom: 4px;
    }
    .badge{
      font-size:12px;
      font-weight:900;
      padding: 6px 10px;
      border-radius: 999px;
      border:1px solid #ddd;
      background:#fff;
      flex:0 0 auto;
    }
    .badge.good{ border-color:#81c784; }
    .badge.warn{ border-color:#ffb74d; }
    .badge.danger{ border-color:#e57373; }

    .chart-controls{
      display:flex;
      flex-wrap:wrap;
      gap:8px;
      margin-bottom:10px;
      align-items:center;
    }
    .chip{
      border:1px solid #ddd;
      background:#fff;
      padding:7px 10px;
      border-radius:999px;
      cursor:pointer;
      font-weight:800;
      font-size:12px;
      color:#333;
      user-select:none;
    }
    .chip.active{
      background:#111;
      border-color:#111;
      color:#fff;
    }
    .legend{
      display:flex;
      flex-wrap:wrap;
      gap:10px;
      margin-top:10px;
      padding-top:10px;
      border-top:1px solid #eee;
    }
    .legend-item{
      display:flex;
      align-items:center;
      gap:6px;
      font-size:12px;
      color:#333;
      border:1px solid #eee;
      background:#fafafa;
      padding:6px 8px;
      border-radius:999px;
    }
    .swatch{
      width:12px;height:12px;border-radius:3px;
      border:1px solid rgba(0,0,0,2);
    }

    canvas{
      width:100%;
      height:220px;
      border:1px solid #e9ecef;
      border-radius:8px;
      background:#fff;
    }
  </style>
</head>

<body>
  <div class="container">
    <header>
      <h1>TeamCMD</h1>
      <!-- <button class="mic-button" id="mic-btn" title="클릭: STT 시작/중지">
        <span class="mic-dot"></span>
        <span id="mic-label">STT 시작</span>
      </button> -->
    </header>

    <div class="statusline" id="statusline">초기화 중...</div>

    <div class="grid">
      <div class="card">
        <h2>대화 입력</h2>
        <div class="body">
          <textarea id="text-input" placeholder="Speaker1: 너 왜 또 늦었어?&#10;Speaker2: 미안해, 차가 막혔어.&#10;"></textarea>

          <div class="btn-row">
            <button class="action" id="reset-btn">새로운 대화</button>
          </div>

          <div class="alert" id="conflict-alert">
            <div>
              <div class="title" id="alert-title">갈등 가능성: 측정 대기</div>
              <div id="alert-detail"></div>
            </div>
            <div class="badge" id="alert-badge">대기</div>
          </div>
        </div>
      </div>

      <div class="card">
        <h2>감정 변화 추이</h2>
        <div class="body">
          <div class="chart-controls">
            <span style="font-weight:800;font-size:12px;color:#333;">화자:</span>
            <div id="speaker-buttons" style="display:flex;gap:8px;flex-wrap:wrap;"></div>
          </div>

          <canvas id="trend-canvas" width="980" height="320"></canvas>

          <div class="legend" id="legend"></div>
        </div>
      </div>
    </div>

    <div class="card" style="margin-top:14px;">
      <h2>대화 기록 및 분석 결과</h2>
      <div class="body">
        <pre id="results-output">불러오는 중...</pre>
      </div>
    </div>
  </div>

  <script>
    document.addEventListener('DOMContentLoaded', function () {
      const textInput = document.getElementById('text-input');
      const resetBtn = document.getElementById('reset-btn');
      const resultsOutput = document.getElementById('results-output');

      const micBtn = document.getElementById('mic-btn');
      const micLabel = document.getElementById('mic-label');

      const statusline = document.getElementById('statusline');

      const alertBox = document.getElementById('conflict-alert');
      const alertTitle = document.getElementById('alert-title');
      const alertDetail = document.getElementById('alert-detail');
      const alertBadge = document.getElementById('alert-badge');

      const canvas = document.getElementById('trend-canvas');
      const ctx = canvas.getContext('2d');

      const speakerButtonsEl = document.getElementById('speaker-buttons');
      const legendEl = document.getElementById('legend');

      const API_URL = window.location.href.replace(/\/+$/,'');
      const WHISPER_WS_URL = 'ws://127.0.0.1:8000/asr';
      const AUTO_ANALYZE_DEBOUNCE_MS = 900;

      let lastAnalysisBlock = '--- 분석 결과 ---\n(아직 없음)\n';

      let sttWs = null;
      let sttStream = null;
      let sttRecorder = null;
      let sttIsRunning = false;

      let debounceTimer = null;
      let lastSnapshotText = '';

      let lastResultObj = null;
      let selectedSpeaker = null;

      const COLOR_PALETTE = [
        '#1f77b4','#ff7f0e','#2ca02c','#d62728','#9467bd',
        '#8c564b','#e377c2','#7f7f7f','#bcbd22','#17becf',
        '#0b3d91','#c2185b','#00695c','#f9a825','#5e35b1'
      ];

      function setStatus(text, ok) {
        statusline.textContent = text;
        statusline.classList.remove('ok', 'bad');
        if (ok === true) statusline.classList.add('ok');
        if (ok === false) statusline.classList.add('bad');
      }

      function safeJsonParse(s) {
        try { return JSON.parse(s); } catch (e) { return null; }
      }

      function speakerLabelFromId(speakerId) {
        if (typeof speakerId === 'number') return 'Speaker' + String(speakerId);
        if (typeof speakerId === 'string') return speakerId;
        return 'Speaker';
      }

      function buildTextareaTextFromLines(lines) {
        const filtered = lines.filter(function (l) {
          return l && typeof l.text === 'string' && l.text.trim().length > 0;
        });
        if (filtered.length === 0) return '';
        return filtered.map(function (l) {
          return speakerLabelFromId(l.speaker) + ': ' + l.text.trim();
        }).join('\n');
      }

      function formatTime(d) {
        const hh = String(d.getHours()).padStart(2,'0');
        const mm = String(d.getMinutes()).padStart(2,'0');
        const ss = String(d.getSeconds()).padStart(2,'0');
        return hh + ':' + mm + ':' + ss;
      }

      function getFutureAlertsObj(resultObj) {
        if (!resultObj || typeof resultObj !== 'object') return null;
        const candidates = [
          resultObj.future_alerts,
          resultObj['future-alerts'],
          resultObj['future-alert'],
          resultObj.futureAlerts
        ];
        for (let i = 0; i < candidates.length; i++) {
          const v = candidates[i];
          if (v && typeof v === 'object') return v;
        }
        return null;
      }

      function normalizeSpeakerKey(s) {
        let raw = String(s || '').trim();

        // 서버/입력에서 "[화자]" 형태로 올 수 있으므로 벗겨낸다.
        const m = raw.match(/^\[([^\]]+)\]$/);
        if (m && m[1]) raw = m[1].trim();

        // "화자:"처럼 콜론이 포함된 키가 오면 정규화한다.
        raw = raw.replace(/\s*:\s*$/, '').trim();

        return raw;
      }

      function summarizeFutureAlerts(futureAlerts) {
        if (!futureAlerts || typeof futureAlerts !== 'object') return { total: 0, bySpeaker: {}, lines: [] };
        const bySpeaker = {};
        const lines = [];
        let total = 0;
        for (const [spkRaw, arr] of Object.entries(futureAlerts)) {
          const spk = normalizeSpeakerKey(spkRaw);
          const list = Array.isArray(arr) ? arr : [];
          bySpeaker[spk] = list;
          total += list.length;
          list.forEach(function (msg) {
            lines.push(spk + ': ' + msg);
          });
        }
        return { total, bySpeaker, lines };
      }

      function decideConflictFromServer(resultObj) {
        const futureAlertsObj = getFutureAlertsObj(resultObj);
        const future = summarizeFutureAlerts(futureAlertsObj);

        const spikes = (resultObj && resultObj.spikes_by_speaker && typeof resultObj.spikes_by_speaker === 'object')
          ? resultObj.spikes_by_speaker
          : {};
        const hasSpikes = Object.keys(spikes).length > 0;

        const alertedSpeakers = Object.keys(future.bySpeaker).filter(function (spk) {
          const arr = future.bySpeaker[spk];
          return Array.isArray(arr) && arr.length > 0;
        });

        let level = 'good';
        let label = '정상';
        let title = '갈등 가능성: 낮음';
        let detail = '서버 예측 기준으로 급격한 갈등 신호가 감지되지 않았습니다.';

        if (future.total > 0 || hasSpikes) {
          level = 'warn';
          label = '경고';
          title = '갈등 가능성: 감지됨';
          detail = '서버 예측(future_alerts / spikes)에 따라 갈등 위험 신호가 존재합니다.';
        }

        const bothSides = alertedSpeakers.length >= 2;
        if (bothSides || future.total >= 4 || hasSpikes) {
          level = 'danger';
          label = '주의';
          title = '갈등 가능성: 높음';
          detail = '서버 예측 기준으로 다수의 갈등 위험 신호가 감지되었습니다.';
        }

        const initiator = resultObj && resultObj.initiator ? resultObj.initiator : null;
        if (initiator) detail += ' (추정 발단 화자: ' + initiator + ')';
        if (future.total > 0) detail += ' (향후 경고 ' + future.total + '건)';
        if (hasSpikes) detail += ' (스파이크 감지)';

        return {
          level, label, title, detail,
          futureLines: future.lines,
          futureTotal: future.total
        };
      }

      function parseTextareaToLines(text) {
        const raw = String(text || '');
        const rows = raw.split(/\r?\n/);
        const lines = [];

        for (let i = 0; i < rows.length; i++) {
          const row = rows[i];
          if (!row || row.trim().length === 0) continue;

          let speaker = 'Manual';
          let content = row.trim();

          // 1) 우선 "화자: 발화" 형식을 최우선으로 파싱
          const m2 = content.match(/^([^:]{1,24})\s*:\s*(.*)$/);
          if (m2) {
            speaker = (m2[1] || '').trim() || 'Manual';
            content = (m2[2] || '').trim();
          } else {
            // 2) 기존 호환: "[화자] 발화" 형식도 허용
            const m1 = content.match(/^\[([^\]]+)\]\s*(.*)$/);
            if (m1) {
              speaker = (m1[1] || '').trim() || 'Manual';
              content = (m1[2] || '').trim();
            }
          }

          if (content.length === 0) continue;

          lines.push({ speaker: speaker, text: content, start: '', end: '', detected_language: 'ko' });
        }

        return lines;
      }

      async function renderHistoryPlusAnalysis() {
        try {
          const response = await fetch(API_URL + '/history', { method: 'GET' });
          const data = await response.json();
          if (!response.ok) throw new Error(data.error || '알 수 없는 서버 오류');

          const serverLines = (data && Array.isArray(data.lines)) ? data.lines : [];
          const historyText = buildTextareaTextFromLines(serverLines);

          const combined =
            '--- 서버 대화 기록 ---\n' +
            (historyText ? historyText : '(없음)') +
            '\n\n' +
            lastAnalysisBlock;

          resultsOutput.textContent = combined;
        } catch (e) {
          resultsOutput.textContent = '오류: ' + e.message;
        }
      }

      function colorForSpeaker(spk, index) {
        const i = index % COLOR_PALETTE.length;
        return COLOR_PALETTE[i];
      }

      function colorForEmotion(emoKey, emotionKeys) {
        const idx = emotionKeys.indexOf(emoKey);
        const i = (idx >= 0 ? idx : 0) % COLOR_PALETTE.length;
        return COLOR_PALETTE[i];
      }

      function clearCanvas() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
      }

      function drawAxes(left, top, right, bottom) {
        const w = canvas.width;
        const h = canvas.height;

        ctx.strokeStyle = '#ddd';
        ctx.lineWidth = 1;

        // x-axis
        ctx.beginPath();
        ctx.moveTo(left, h - bottom);
        ctx.lineTo(w - right, h - bottom);
        ctx.stroke();

        // y-axis
        ctx.beginPath();
        ctx.moveTo(left, top);
        ctx.lineTo(left, h - bottom);
        ctx.stroke();
      }

      function drawMultiEmotionTrend() {
        clearCanvas();

        const resultObj = lastResultObj;
        if (!resultObj || typeof resultObj !== 'object') {
          ctx.fillStyle = '#666';
          ctx.font = '14px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto';
          ctx.fillText('분석 결과가 없습니다.', 14, 22);
          return;
        }

        // ✅ 서버 응답은 per_utt_log에 시계열이 있음
        const series = (resultObj && Array.isArray(resultObj.per_utt_log)) ? resultObj.per_utt_log : [];
        if (!series.length) {
          ctx.fillStyle = '#666';
          ctx.font = '14px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto';
          ctx.fillText('시계열(per_utt_log)이 비어 있습니다.', 14, 22);
          return;
        }

        // 선택 화자 필터
        const filtered = selectedSpeaker
          ? series.filter(function (it) { return String(it.speaker) === String(selectedSpeaker); })
          : series.slice();

        if (!filtered.length) {
          ctx.fillStyle = '#666';
          ctx.font = '14px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto';
          ctx.fillText('선택 화자 데이터가 없습니다.', 14, 22);
          return;
        }

        // 감정 키 추정(negative_emotions 우선, 없으면 emotions)
        const sample = filtered[0] || {};
        const emoObj = (sample.negative_emotions && typeof sample.negative_emotions === 'object')
          ? sample.negative_emotions
          : ((sample.emotions && typeof sample.emotions === 'object') ? sample.emotions : {});
        const emotionKeys = Object.keys(emoObj || {}).slice(0, 6);

        const w = canvas.width;
        const h = canvas.height;
        const left = 46;
        const right = 18;
        const top = 22;
        const bottom = 30;

        drawAxes(left, top, right, bottom);

        // ✅ 데이터 범위: 0~100 스케일
        const maxY = 100.0;
        const minY = 0.0;

        const xAt = function (idx) {
          if (filtered.length <= 1) return left;
          const t = idx / (filtered.length - 1);
          return left + t * (w - left - right);
        };
        const yAt = function (val) {
          const clamped = Math.max(minY, Math.min(maxY, val));
          const t = (clamped - minY) / (maxY - minY);
          return (h - bottom) - t * (h - top - bottom);
        };

        // 라인 + 점
        emotionKeys.forEach(function (ek) {
          ctx.beginPath();
          for (let i = 0; i < filtered.length; i++) {
            const emo = filtered[i].negative_emotions || filtered[i].emotions || {};
            const v = Number(emo[ek]);
            const val = Number.isFinite(v) ? v : 0;
            const x = xAt(i);
            const y = yAt(val);
            if (i === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
          }
          ctx.strokeStyle = colorForEmotion(ek, emotionKeys);
          ctx.lineWidth = 2;
          ctx.stroke();
        });

        const m = filtered.length;
        emotionKeys.forEach(function (ek) {
          const emo = filtered[m - 1].negative_emotions || filtered[m - 1].emotions || {};
          const v = Number(emo[ek]);
          const val = Number.isFinite(v) ? v : 0;
          const x = xAt(m - 1);
          const y = yAt(val);

          ctx.fillStyle = colorForEmotion(ek, emotionKeys);
          ctx.beginPath();
          ctx.arc(x, y, 3.5, 0, Math.PI * 2);
          ctx.fill();
        });

        ctx.fillStyle = '#555';
        ctx.font = '12px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto';
        ctx.fillText('turn 1', left, h - 10);
        ctx.fillText('turn ' + String(m), w - right - 60, h - 10);

        ctx.fillStyle = '#111';
        ctx.font = '13px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto';
        ctx.fillText(
          'Speaker: ' + (selectedSpeaker ? String(selectedSpeaker) : 'ALL') + '  |  Top ' + String(emotionKeys.length) + ' emotions',
          left,
          14
        );

        // legend
        legendEl.innerHTML = '';
        emotionKeys.forEach(function (ek) {
          const item = document.createElement('div');
          item.className = 'legend-item';
          const sw = document.createElement('div');
          sw.className = 'swatch';
          sw.style.background = colorForEmotion(ek, emotionKeys);
          const label = document.createElement('div');
          label.textContent = ek;
          item.appendChild(sw);
          item.appendChild(label);
          legendEl.appendChild(item);
        });
      }

      function rebuildSpeakerButtons() {
        speakerButtonsEl.innerHTML = '';
        const resultObj = lastResultObj;
        if (!resultObj || typeof resultObj !== 'object') return;

        // ✅ 서버 응답은 per_utt_log에 화자들이 있음
        const series = (resultObj && Array.isArray(resultObj.per_utt_log)) ? resultObj.per_utt_log : [];
        const speakers = Array.from(new Set(series.map(function (it) { return String(it.speaker); })));

        if (!selectedSpeaker && speakers.length > 0) {
          selectedSpeaker = speakers[0];
        }


        speakers.forEach(function (spk, idx) {
          const chip = document.createElement('div');
          const active = (String(selectedSpeaker) === String(spk));
          chip.className = 'chip' + (active ? ' active' : '');
          chip.textContent = spk;
          chip.addEventListener('click', function () {
            selectedSpeaker = spk;
            rebuildSpeakerButtons();
            drawMultiEmotionTrend();
          });
          speakerButtonsEl.appendChild(chip);
        });
      }

      async function sendAnalyzeSnapshot(lines) {
        lastAnalysisBlock = '--- 분석 결과 ---\n(분석 중...)\n';
        await renderHistoryPlusAnalysis();

        try {
          const response = await fetch(API_URL + '/analyze_snapshot?alpha=0.1&z=1.8&steps=3', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ lines: lines })
          });

          const data = await response.json();

          console.log('[ANALYZE] raw response json:', data);

          if (!response.ok) throw new Error(data.error || '알 수 없는 서버 오류');

          lastResultObj = data.result || null;

          console.log('[ANALYZE] result:', lastResultObj);

          rebuildSpeakerButtons();
          drawMultiEmotionTrend();

          const decision = decideConflictFromServer(lastResultObj);

          alertBox.classList.remove('good','warn','danger');
          alertBox.classList.add(decision.level);
          alertBadge.classList.remove('good','warn','danger');
          alertBadge.classList.add(decision.level);
          alertBadge.textContent = decision.label;
          alertTitle.textContent = decision.title;
          alertDetail.textContent = decision.detail;

          let futureText = '';
          if (decision.futureLines && decision.futureLines.length) {
            futureText = '\n--- future_alerts ---\n' + decision.futureLines.map(function (s) { return '  - ' + s; }).join('\n') + '\n';
          } else {
            futureText = '\n--- future_alerts ---\n  (없음)\n';
          }

          const keysDebug = lastResultObj && typeof lastResultObj === 'object'
            ? Object.keys(lastResultObj)
            : [];

          lastAnalysisBlock =
            '--- 분석 결과 ---\n' +
            '시간: ' + formatTime(new Date()) + '\n' +
            'result keys: ' + JSON.stringify(keysDebug) + '\n' +
            '갈등 판단(서버 기준): ' + decision.title + ' [' + decision.label + ']\n' +
            '요약: ' + decision.detail + '\n' +
            '경고 건수(future_alerts): ' + String(decision.futureTotal) + '\n' +
            futureText;

          await renderHistoryPlusAnalysis();
        } catch (e) {
          console.error('[ANALYZE] error:', e);

          lastAnalysisBlock = '--- 분석 결과 ---\n오류 발생: ' + e.message + '\n';
          await renderHistoryPlusAnalysis();
        }
      }

      textInput.addEventListener('keydown', function (e) {
        if (e.isComposing) return;
        if (e.key === 'Enter' && !e.shiftKey) {
          e.preventDefault();
          const lines = parseTextareaToLines(textInput.value);
          if (debounceTimer) { clearTimeout(debounceTimer); debounceTimer = null; }
          sendAnalyzeSnapshot(lines).catch(function (err) { console.error(err); });
        }
      });

      resetBtn.addEventListener('click', async function (event) {
        event.preventDefault();
        if (!confirm('서버의 대화 기록을 정말로 초기화하고 새로운 대화를 시작하시겠습니까?')) return;

        lastAnalysisBlock = '--- 분석 결과 ---\n(초기화 중...)\n';
        await renderHistoryPlusAnalysis();

        try {
          const response = await fetch(API_URL + '/reset', { method: 'POST' });
          const data = await response.json();
          if (!response.ok) throw new Error(data.error || '알 수 없는 서버 오류');

          lastResultObj = null;
          selectedSpeaker = null;
          speakerButtonsEl.innerHTML = '';
          legendEl.innerHTML = '';

          alertBox.classList.remove('good','warn','danger');
          alertBadge.classList.remove('good','warn','danger');
          alertTitle.textContent = '갈등 가능성: 측정 대기';
          alertDetail.textContent = '';
          alertBadge.textContent = '대기';

          setStatus('초기화 완료. 새 대화를 입력하세요. (Enter=분석, Shift+Enter=줄바꿈)', true);
          textInput.value = '';
          lastSnapshotText = '';

          await renderHistoryPlusAnalysis();
          drawMultiEmotionTrend();
        } catch (e) {
          setStatus('초기화 실패: ' + e.message, false);
          lastAnalysisBlock = '--- 분석 결과 ---\n초기화 실패: ' + e.message + '\n';
          await renderHistoryPlusAnalysis();
        }
      });

      async function bootstrap() {
        setStatus('서버 연결 확인 중...', null);
        try {
          const resp = await fetch(API_URL + '/ping', { method: 'GET' });
          const data = await resp.json();
          if (!resp.ok) throw new Error(data.error || 'ping 실패');
          setStatus('서버 연결 OK. 대화를 입력하세요. (Enter=분석, Shift+Enter=줄바꿈)', true);
        } catch (e) {
          setStatus('서버 연결 실패: ' + e.message, false);
        }

        await renderHistoryPlusAnalysis();
        drawMultiEmotionTrend();
      }

      bootstrap().catch(function (e) {
        console.error(e);
        setStatus('초기화 오류: ' + e.message, false);
      });
    });
  </script>
</body>
</html>
