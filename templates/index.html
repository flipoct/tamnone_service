<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>TeamCMD</title>
  <style>
    body{
      font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,Oxygen,Ubuntu,Cantarell,'Open Sans','Helvetica Neue',sans-serif;
      background-color:#f0f2f5;
      display:flex;
      justify-content:center;
      align-items:flex-start;
      min-height:100vh;
      margin:0;
      padding:28px 0;
      overflow-y:auto;
    }
    .container{
      background:#fff;
      padding:24px;
      border-radius:12px;
      box-shadow:0 4px 12px rgba(0,0,0,.1);
      width:100%;
      max-width:1100px;
    }
    header{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      margin-bottom:14px;
    }
    h1{ margin:0; color:#222; font-size:22px; }

    .mic-button{
      background:#f0f0f0;
      border:1px solid #ddd;
      border-radius:999px;
      padding:10px 14px;
      cursor:pointer;
      transition:background-color .2s,border-color .2s;
      display:flex;
      align-items:center;
      gap:10px;
      user-select:none;
    }
    .mic-dot{ width:10px;height:10px;border-radius:50%; background:#777; }
    .mic-button.active{ background:#ffebee; border-color:#ef9a9a; }
    .mic-button.active .mic-dot{ background:#d32f2f; }

    .grid{
      display:grid;
      grid-template-columns: 1.1fr .9fr;
      gap:14px;
      align-items:start;
    }
    @media (max-width: 980px){ .grid{ grid-template-columns: 1fr; } }

    .card{
      border:1px solid #e9ecef;
      border-radius:10px;
      background:#fff;
      overflow:hidden;
    }
    .card h2{
      margin:0;
      padding:12px 14px;
      font-size:15px;
      border-bottom:1px solid #eee;
      color:#222;
      background:#fafafa;
    }
    .card .body{ padding:12px 14px; }

    textarea{
      width:100%;
      height:260px;
      padding:12px;
      border:1px solid #ccc;
      border-radius:8px;
      box-sizing:border-box;
      font-size:14px;
      line-height:1.5;
      resize:vertical;
      white-space:pre-wrap;
    }

    .btn-row{
      display:flex;
      gap:10px;
      margin-top:10px;
    }
    button.action{
      flex:1;
      padding:12px 10px;
      border:none;
      border-radius:8px;
      cursor:pointer;
      font-weight:700;
      color:#fff;
      background:#6c757d;
      transition:background-color .2s;
    }
    button.action:hover{ background:#5a6268; }

    .alert{
      margin:14px 0 0 0;
      padding:12px 14px;
      border-radius:10px;
      border:1px solid #e9ecef;
      background:#f8f9fa;
      color:#222;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      flex-wrap:wrap;
    }
    .alert.good{ border-color:#c8e6c9; background:#e8f5e9; }
    .alert.warn{ border-color:#ffe0b2; background:#fff3e0; }
    .alert.danger{ border-color:#ffcdd2; background:#ffebee; }
    .alert .title{ font-weight:800; }
    .badge{
      padding:6px 10px;
      border-radius:999px;
      font-weight:800;
      font-size:12px;
      color:#fff;
      background:#607d8b;
      white-space:nowrap;
    }
    .badge.good{ background:#2e7d32; }
    .badge.warn{ background:#ef6c00; }
    .badge.danger{ background:#c62828; }

    pre{
      margin:0;
      white-space:pre-wrap;
      word-break:break-word;
      font-family: ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;
      font-size:12.5px;
      color:#333;
      background:#f8f9fa;
      border:1px solid #e9ecef;
      border-radius:8px;
      padding:12px;
      max-height:380px;
      overflow:auto;
    }

    .statusline{
      margin: 0 0 14px 0;
      padding: 10px 12px;
      border-radius: 10px;
      border: 1px solid #e9ecef;
      background:#f8f9fa;
      color:#333;
      font-size: 13px;
      line-height: 1.4;
    }
    .statusline.ok{ border-color:#c8e6c9; background:#e8f5e9; }
    .statusline.bad{ border-color:#ffcdd2; background:#ffebee; }

    .chart-controls{
      display:flex;
      flex-wrap:wrap;
      gap:8px;
      margin-bottom:10px;
      align-items:center;
    }
    .chip{
      border:1px solid #ddd;
      background:#fff;
      padding:7px 10px;
      border-radius:999px;
      cursor:pointer;
      font-weight:800;
      font-size:12px;
      color:#333;
      user-select:none;
    }
    .chip.active{
      background:#111;
      border-color:#111;
      color:#fff;
    }
    .legend{
      display:flex;
      flex-wrap:wrap;
      gap:10px;
      margin-top:10px;
      padding-top:10px;
      border-top:1px solid #eee;
    }
    .legend-item{
      display:flex;
      align-items:center;
      gap:6px;
      font-size:12px;
      color:#333;
      border:1px solid #eee;
      background:#fafafa;
      padding:6px 8px;
      border-radius:999px;
    }
    .swatch{
      width:12px;height:12px;border-radius:3px;
      border:1px solid rgba(0,0,0,.2);
    }

    canvas{
      width:100%;
      height:220px;
      border:1px solid #e9ecef;
      border-radius:8px;
      background:#fff;
    }
  </style>
</head>

<body>
  <div class="container">
    <header>
      <h1>TeamCMD</h1>
      <button class="mic-button" id="mic-btn" title="클릭: STT 시작/중지">
        <span class="mic-dot"></span>
        <span id="mic-label">STT 시작</span>
      </button>
    </header>

    <div class="statusline" id="statusline">초기화 중...</div>

    <div class="grid">
      <div class="card">
        <h2>대화 입력</h2>
        <div class="body">
          <textarea id="text-input" placeholder="[Speaker1] 너 왜 또 늦었어?&#10;[Speaker2] 미안해, 차가 막혔어.&#10;"></textarea>

          <div class="btn-row">
            <button class="action" id="reset-btn">새로운 대화</button>
          </div>

          <div class="alert" id="conflict-alert">
            <div>
              <div class="title" id="alert-title">갈등 가능성: 측정 대기</div>
              <div id="alert-detail"></div>
            </div>
            <div class="badge" id="alert-badge">대기</div>
          </div>
        </div>
      </div>

      <div class="card">
        <h2>감정 변화 추이</h2>
        <div class="body">
          <div class="chart-controls">
            <span style="font-weight:800;font-size:12px;color:#333;">화자:</span>
            <div id="speaker-buttons" style="display:flex;gap:8px;flex-wrap:wrap;"></div>
          </div>

          <canvas id="trend-canvas" width="980" height="320"></canvas>

          <div class="legend" id="legend"></div>
        </div>
      </div>
    </div>

    <div class="card" style="margin-top:14px;">
      <h2>대화 기록 및 분석 결과</h2>
      <div class="body">
        <pre id="results-output">불러오는 중...</pre>
      </div>
    </div>
  </div>

  <script>
    document.addEventListener('DOMContentLoaded', function () {
      const textInput = document.getElementById('text-input');
      const resetBtn = document.getElementById('reset-btn');
      const resultsOutput = document.getElementById('results-output');

      const micBtn = document.getElementById('mic-btn');
      const micLabel = document.getElementById('mic-label');

      const statusline = document.getElementById('statusline');

      const alertBox = document.getElementById('conflict-alert');
      const alertTitle = document.getElementById('alert-title');
      const alertDetail = document.getElementById('alert-detail');
      const alertBadge = document.getElementById('alert-badge');

      const canvas = document.getElementById('trend-canvas');
      const ctx = canvas.getContext('2d');

      const speakerButtonsEl = document.getElementById('speaker-buttons');
      const legendEl = document.getElementById('legend');

      const API_URL = 'http://127.0.0.1:5000';
      const WHISPER_WS_URL = 'ws://127.0.0.1:8000/asr';
      const AUTO_ANALYZE_DEBOUNCE_MS = 900;

      let lastAnalysisBlock = '--- 분석 결과 ---\n(아직 없음)\n';

      let sttWs = null;
      let sttStream = null;
      let sttRecorder = null;
      let sttIsRunning = false;

      let debounceTimer = null;
      let lastSnapshotText = '';

      let lastResultObj = null;
      let selectedSpeaker = null;

      const COLOR_PALETTE = [
        '#1f77b4','#ff7f0e','#2ca02c','#d62728','#9467bd',
        '#8c564b','#e377c2','#7f7f7f','#bcbd22','#17becf',
        '#0b3d91','#c2185b','#00695c','#f9a825','#5e35b1'
      ];

      function setStatus(text, ok) {
        statusline.textContent = text;
        statusline.classList.remove('ok', 'bad');
        if (ok === true) statusline.classList.add('ok');
        if (ok === false) statusline.classList.add('bad');
      }

      function safeJsonParse(s) {
        try { return JSON.parse(s); } catch (e) { return null; }
      }

      function speakerLabelFromId(speakerId) {
        if (typeof speakerId === 'number') return 'Speaker' + String(speakerId);
        if (typeof speakerId === 'string') return speakerId;
        return 'Speaker';
      }

      function buildTextareaTextFromLines(lines) {
        const filtered = lines.filter(function (l) {
          return l && typeof l.text === 'string' && l.text.trim().length > 0;
        });
        if (filtered.length === 0) return '';
        return filtered.map(function (l) {
          return '[' + speakerLabelFromId(l.speaker) + '] ' + l.text.trim();
        }).join('\n');
      }

      function formatTime(d) {
        const hh = String(d.getHours()).padStart(2,'0');
        const mm = String(d.getMinutes()).padStart(2,'0');
        const ss = String(d.getSeconds()).padStart(2,'0');
        return hh + ':' + mm + ':' + ss;
      }

      function getFutureAlertsObj(resultObj) {
        if (!resultObj || typeof resultObj !== 'object') return null;
        const candidates = [
          resultObj.future_alerts,
          resultObj['future-alerts'],
          resultObj['future-alert'],
          resultObj.futureAlerts
        ];
        for (let i = 0; i < candidates.length; i++) {
          const v = candidates[i];
          if (v && typeof v === 'object') return v;
        }
        return null;
      }

      function normalizeSpeakerKey(s) {
        const raw = String(s || '').trim();
        const m = raw.match(/^\[([^\]]+)\]$/);
        if (m && m[1]) return m[1].trim();
        return raw;
      }

      function summarizeFutureAlerts(futureAlerts) {
        if (!futureAlerts || typeof futureAlerts !== 'object') return { total: 0, bySpeaker: {}, lines: [] };
        const bySpeaker = {};
        const lines = [];
        let total = 0;
        for (const [spkRaw, arr] of Object.entries(futureAlerts)) {
          const spk = normalizeSpeakerKey(spkRaw);
          const list = Array.isArray(arr) ? arr : [];
          bySpeaker[spk] = list;
          total += list.length;
          list.forEach(function (msg) {
            lines.push('[' + spk + '] ' + msg);
          });
        }
        return { total, bySpeaker, lines };
      }

      function decideConflictFromServer(resultObj) {
        const futureAlertsObj = getFutureAlertsObj(resultObj);
        const future = summarizeFutureAlerts(futureAlertsObj);

        const spikes = (resultObj && resultObj.spikes_by_speaker && typeof resultObj.spikes_by_speaker === 'object')
          ? resultObj.spikes_by_speaker
          : {};
        const hasSpikes = Object.keys(spikes).length > 0;

        const alertedSpeakers = Object.keys(future.bySpeaker).filter(function (spk) {
          const arr = future.bySpeaker[spk];
          return Array.isArray(arr) && arr.length > 0;
        });

        let level = 'good';
        let label = '정상';
        let title = '갈등 가능성: 낮음';
        let detail = '서버 예측 기준으로 급격한 갈등 신호가 감지되지 않았습니다.';

        if (future.total > 0 || hasSpikes) {
          level = 'warn';
          label = '경고';
          title = '갈등 가능성: 감지됨';
          detail = '서버 예측(future_alerts / spikes)에 따라 갈등 위험 신호가 존재합니다.';
        }

        const bothSides = alertedSpeakers.length >= 2;
        if (bothSides || future.total >= 4 || hasSpikes) {
          level = 'danger';
          label = '주의';
          title = '갈등 가능성: 높음';
          detail = '서버 예측 기준으로 다수의 갈등 위험 신호가 감지되었습니다.';
        }

        const initiator = resultObj && resultObj.initiator ? resultObj.initiator : null;
        if (initiator) detail += ' (추정 발단 화자: ' + initiator + ')';
        if (future.total > 0) detail += ' (향후 경고 ' + future.total + '건)';
        if (hasSpikes) detail += ' (스파이크 감지)';

        return {
          level, label, title, detail,
          futureLines: future.lines,
          futureTotal: future.total
        };
      }

      function parseTextareaToLines(text) {
        const raw = String(text || '');
        const rows = raw.split(/\r?\n/);
        const lines = [];

        for (let i = 0; i < rows.length; i++) {
          const row = rows[i];
          if (!row || row.trim().length === 0) continue;

          let speaker = 'Manual';
          let content = row.trim();

          const m1 = content.match(/^\[([^\]]+)\]\s*(.*)$/);
          if (m1) {
            speaker = (m1[1] || '').trim() || 'Manual';
            content = (m1[2] || '').trim();
          } else {
            const m2 = content.match(/^([^:]{1,24})\s*:\s*(.*)$/);
            if (m2) {
              speaker = (m2[1] || '').trim() || 'Manual';
              content = (m2[2] || '').trim();
            }
          }

          if (content.length === 0) continue;
          lines.push({ speaker: speaker, text: content, start: '', end: '', detected_language: 'ko' });
        }

        if (lines.length === 0 && raw.trim().length > 0) {
          lines.push({ speaker: 'Manual', text: raw.trim(), start: '', end: '', detected_language: 'ko' });
        }
        return lines;
      }

      async function fetchHistory() {
        const controller = new AbortController();
        const timer = setTimeout(function () { controller.abort(); }, 4000);
        try {
          const res = await fetch(API_URL + '/history', { signal: controller.signal });
          if (!res.ok) throw new Error('history fetch failed (' + res.status + ')');
          return await res.json();
        } finally {
          clearTimeout(timer);
        }
      }

      async function renderHistoryPlusAnalysis() {
        try {
          const data = await fetchHistory();
          const history = Array.isArray(data.history) ? data.history : [];
          const historyText = history.length > 0
            ? ('--- 전체 대화 기록 ---\n\n' + history.join('\n'))
            : ('--- 전체 대화 기록 ---\n\n(기록 없음)');
          resultsOutput.textContent = historyText + '\n\n' + lastAnalysisBlock;
          setStatus('서버 연결: OK  |  /history 로드 완료', true);
        } catch (e) {
          resultsOutput.textContent = '대화 기록 불러오기 실패: ' + e.message + '\n\n' + lastAnalysisBlock;
          setStatus('서버 연결 실패: ' + e.message + '  (API_URL=' + API_URL + ')', false);
        }
      }

      function getSpeakersFromPerLog(perLog) {
        const s = new Set();
        perLog.forEach(function (u) {
          if (!u) return;
          if (u.speaker !== undefined && u.speaker !== null) s.add(String(u.speaker));
        });
        return Array.from(s);
      }

      function pickTopEmotionsForSpeaker(perLog, speaker, k) {
        const acc = new Map();
        perLog.forEach(function (u) {
          if (!u || String(u.speaker) !== String(speaker)) return;
          const emo = u.negative_emotions;
          if (!emo || typeof emo !== 'object') return;
          Object.entries(emo).forEach(function (kv) {
            const key = kv[0];
            const val = Number(kv[1]);
            if (!Number.isFinite(val)) return;
            if (!acc.has(key)) acc.set(key, { sum: 0, cnt: 0 });
            const o = acc.get(key);
            o.sum += val;
            o.cnt += 1;
          });
        });

        const ranked = Array.from(acc.entries())
          .map(function (it) {
            const key = it[0];
            const o = it[1];
            return [key, o.cnt ? (o.sum / o.cnt) : 0];
          })
          .sort(function (a,b) { return b[1] - a[1]; });

        return ranked.slice(0, k).map(function (x) { return x[0]; });
      }

      function colorForEmotion(emotionKey, emotionKeys) {
        const idx = emotionKeys.indexOf(emotionKey);
        return COLOR_PALETTE[(idx >= 0 ? idx : 0) % COLOR_PALETTE.length];
      }

      function rebuildSpeakerButtons() {
        speakerButtonsEl.innerHTML = '';

        const perLog = lastResultObj && Array.isArray(lastResultObj.per_utt_log) ? lastResultObj.per_utt_log : [];
        const speakers = getSpeakersFromPerLog(perLog);

        if (speakers.length === 0) return;

        if (selectedSpeaker === null || !speakers.includes(String(selectedSpeaker))) {
          selectedSpeaker = speakers[0];
        }

        speakers.forEach(function (spk) {
          const btn = document.createElement('div');
          btn.className = 'chip' + (String(spk) === String(selectedSpeaker) ? ' active' : '');
          btn.textContent = spk;
          btn.addEventListener('click', function () {
            selectedSpeaker = spk;
            rebuildSpeakerButtons();
            drawMultiEmotionTrend();
          });
          speakerButtonsEl.appendChild(btn);
        });
      }

      function setLegend(emotionKeys) {
        legendEl.innerHTML = '';
        emotionKeys.forEach(function (k) {
          const item = document.createElement('div');
          item.className = 'legend-item';

          const sw = document.createElement('div');
          sw.className = 'swatch';
          sw.style.backgroundColor = colorForEmotion(k, emotionKeys);

          const t = document.createElement('div');
          t.textContent = k;

          item.appendChild(sw);
          item.appendChild(t);
          legendEl.appendChild(item);
        });
      }

      function drawMultiEmotionTrend() {
        const w = canvas.width;
        const h = canvas.height;
        ctx.clearRect(0, 0, w, h);

        const left = 60, right = 16, top = 18, bottom = 34;
        const plotW = w - left - right;
        const plotH = h - top - bottom;

        ctx.beginPath();
        for (let i = 0; i <= 5; i++) {
          const y = top + (plotH * (1 - i / 5));
          ctx.moveTo(left, y);
          ctx.lineTo(w - right, y);
        }
        ctx.strokeStyle = '#e9ecef';
        ctx.lineWidth = 1;
        ctx.stroke();

        ctx.fillStyle = '#555';
        ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
        for (let i = 0; i <= 5; i++) {
          const val = i * 20;
          const y = top + (plotH * (1 - i / 5));
          ctx.fillText(String(val), 10, y + 4);
        }

        const perLog = lastResultObj && Array.isArray(lastResultObj.per_utt_log) ? lastResultObj.per_utt_log : [];
        if (!selectedSpeaker || perLog.length === 0) {
          ctx.fillStyle = '#777';
          ctx.font = '13px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto';
          ctx.fillText('분석 데이터가 없거나 화자가 선택되지 않았습니다.', left, top + 14);
          legendEl.innerHTML = '';
          return;
        }

        const filtered = perLog.filter(function (u) { return u && String(u.speaker) === String(selectedSpeaker); });
        if (filtered.length < 2) {
          ctx.fillStyle = '#777';
          ctx.font = '13px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto';
          ctx.fillText('해당 화자의 발화가 2개 이상 쌓이면 그래프가 표시됩니다.', left, top + 14);
          legendEl.innerHTML = '';
          return;
        }

        const K = 6;
        const emotionKeys = pickTopEmotionsForSpeaker(perLog, selectedSpeaker, K);
        setLegend(emotionKeys);

        const m = filtered.length;
        function xAt(i) { return left + (plotW * (i / Math.max(1, m - 1))); }
        function yAt(val) {
          const clamped = Math.max(0, Math.min(100, val));
          return top + plotH * (1 - clamped / 100);
        }

        emotionKeys.forEach(function (ek) {
          ctx.beginPath();
          for (let i = 0; i < m; i++) {
            const emo = filtered[i].negative_emotions || {};
            const v = Number(emo[ek]);
            const val = Number.isFinite(v) ? v : 0;
            const x = xAt(i);
            const y = yAt(val);
            if (i === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
          }
          ctx.strokeStyle = colorForEmotion(ek, emotionKeys);
          ctx.lineWidth = 2;
          ctx.stroke();
        });

        emotionKeys.forEach(function (ek) {
          const emo = filtered[m - 1].negative_emotions || {};
          const v = Number(emo[ek]);
          const val = Number.isFinite(v) ? v : 0;
          const x = xAt(m - 1);
          const y = yAt(val);

          ctx.fillStyle = colorForEmotion(ek, emotionKeys);
          ctx.beginPath();
          ctx.arc(x, y, 3.5, 0, Math.PI * 2);
          ctx.fill();
        });

        ctx.fillStyle = '#555';
        ctx.font = '12px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto';
        ctx.fillText('turn 1', left, h - 10);
        ctx.fillText('turn ' + String(m), w - right - 60, h - 10);

        ctx.fillStyle = '#111';
        ctx.font = '13px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto';
        ctx.fillText('Speaker: ' + String(selectedSpeaker) + '  |  Top ' + String(emotionKeys.length) + ' emotions', left, 14);
      }

      async function sendAnalyzeSnapshot(lines) {
        lastAnalysisBlock = '--- 분석 결과 ---\n(분석 중...)\n';
        await renderHistoryPlusAnalysis();

        try {
          const response = await fetch(API_URL + '/analyze_snapshot', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ lines: lines })
          });

          const data = await response.json();

          // ✅ 여기: 분석 결과(JSON) 받을 때마다 콘솔에 찍기
          console.log('[ANALYZE] raw response json:', data);

          if (!response.ok) throw new Error(data.error || '알 수 없는 서버 오류');

          lastResultObj = data.result || null;

          // ✅ 여기: result 자체도 별도로 찍기(원하면 유지)
          console.log('[ANALYZE] result:', lastResultObj);

          rebuildSpeakerButtons();
          drawMultiEmotionTrend();

          const decision = decideConflictFromServer(lastResultObj);

          alertBox.classList.remove('good','warn','danger');
          alertBox.classList.add(decision.level);
          alertBadge.classList.remove('good','warn','danger');
          alertBadge.classList.add(decision.level);
          alertBadge.textContent = decision.label;
          alertTitle.textContent = decision.title;
          alertDetail.textContent = decision.detail;

          let futureText = '';
          if (decision.futureLines && decision.futureLines.length) {
            futureText = '\n--- future_alerts ---\n' + decision.futureLines.map(function (s) { return '  - ' + s; }).join('\n') + '\n';
          } else {
            futureText = '\n--- future_alerts ---\n  (없음)\n';
          }

          const keysDebug = lastResultObj && typeof lastResultObj === 'object'
            ? Object.keys(lastResultObj)
            : [];

          lastAnalysisBlock =
            '--- 분석 결과 ---\n' +
            '시간: ' + formatTime(new Date()) + '\n' +
            'result keys: ' + JSON.stringify(keysDebug) + '\n' +
            '갈등 판단(서버 기준): ' + decision.title + ' [' + decision.label + ']\n' +
            '요약: ' + decision.detail + '\n' +
            '경고 건수(future_alerts): ' + String(decision.futureTotal) + '\n' +
            futureText;

          await renderHistoryPlusAnalysis();
        } catch (e) {
          // ✅ 오류도 콘솔에
          console.error('[ANALYZE] error:', e);

          lastAnalysisBlock = '--- 분석 결과 ---\n오류 발생: ' + e.message + '\n';
          await renderHistoryPlusAnalysis();
        }
      }

      textInput.addEventListener('keydown', function (e) {
        if (e.isComposing) return;
        if (e.key === 'Enter' && !e.shiftKey) {
          e.preventDefault();
          const lines = parseTextareaToLines(textInput.value);
          if (debounceTimer) { clearTimeout(debounceTimer); debounceTimer = null; }
          sendAnalyzeSnapshot(lines).catch(function (err) { console.error(err); });
        }
      });

      resetBtn.addEventListener('click', async function (event) {
        event.preventDefault();
        if (!confirm('서버의 대화 기록을 정말로 초기화하고 새로운 대화를 시작하시겠습니까?')) return;

        lastAnalysisBlock = '--- 분석 결과 ---\n(초기화 중...)\n';
        await renderHistoryPlusAnalysis();

        try {
          const response = await fetch(API_URL + '/reset', { method: 'POST' });
          const data = await response.json();

          lastAnalysisBlock = '--- 분석 결과 ---\n' + (data.message || '대화 기록이 초기화되었습니다.') + '\n';

          lastResultObj = null;
          selectedSpeaker = null;
          speakerButtonsEl.innerHTML = '';
          legendEl.innerHTML = '';
          ctx.clearRect(0,0,canvas.width,canvas.height);

          alertBox.classList.remove('good','warn','danger');
          alertTitle.textContent = '갈등 가능성: 측정 대기';
          alertDetail.textContent = 'STT 또는 수동 입력 후 Enter를 누르면 분석 결과가 갱신됩니다.';
          alertBadge.classList.remove('good','warn','danger');
          alertBadge.textContent = '대기';

          lastSnapshotText = '';
          textInput.value = '';
        } catch (e) {
          lastAnalysisBlock = '--- 분석 결과 ---\n오류 발생: ' + e.message + '\n';
        }

        await renderHistoryPlusAnalysis();
      });

      async function maybeAutoAnalyzeFromSnapshot(msgObj) {
        if (!msgObj || !Array.isArray(msgObj.lines)) return;

        const snapshotText = buildTextareaTextFromLines(msgObj.lines);
        if (snapshotText === lastSnapshotText) return;
        lastSnapshotText = snapshotText;

        textInput.value = snapshotText;

        if (debounceTimer) { clearTimeout(debounceTimer); debounceTimer = null; }
        debounceTimer = setTimeout(async function () {
          await sendAnalyzeSnapshot(msgObj.lines);
        }, AUTO_ANALYZE_DEBOUNCE_MS);
      }

      async function waitWsOpen(ws, timeoutMs) {
        if (ws.readyState === WebSocket.OPEN) return;
        const to = typeof timeoutMs === 'number' ? timeoutMs : 7000;

        await new Promise(function (resolve, reject) {
          const timer = setTimeout(function () { reject(new Error('WebSocket open timeout')); }, to);
          ws.addEventListener('open', function () { clearTimeout(timer); resolve(); }, { once: true });
          ws.addEventListener('error', function () { clearTimeout(timer); reject(new Error('WebSocket error before open')); }, { once: true });
        });
      }

      async function startStt() {
        if (sttIsRunning) return;

        lastSnapshotText = '';
        if (debounceTimer) { clearTimeout(debounceTimer); debounceTimer = null; }

        sttStream = await navigator.mediaDevices.getUserMedia({ audio: true });

        sttWs = new WebSocket(WHISPER_WS_URL);
        sttWs.binaryType = 'arraybuffer';

        sttWs.onopen = async function () {
          sttIsRunning = true;
          micBtn.classList.add('active');
          micLabel.textContent = 'STT 중지';
          lastAnalysisBlock = '--- 분석 결과 ---\n(STT 연결됨)\n';
          setStatus('STT 연결: OK  |  WS=' + WHISPER_WS_URL, true);
          await renderHistoryPlusAnalysis();
        };

        sttWs.onerror = async function () {
          lastAnalysisBlock = '--- 분석 결과 ---\n(STT WebSocket 오류)\n';
          setStatus('STT 연결: 실패  |  WS=' + WHISPER_WS_URL, false);
          await renderHistoryPlusAnalysis();
        };

        sttWs.onclose = async function () {
          if (sttIsRunning) await stopStt();
        };

        sttWs.onmessage = function (evt) {
          if (typeof evt.data !== 'string') return;
          const obj = safeJsonParse(evt.data);
          if (!obj || !Array.isArray(obj.lines)) return;
          maybeAutoAnalyzeFromSnapshot(obj).catch(function (e) { console.error(e); });
        };

        await waitWsOpen(sttWs, 7000);

        const mimeCandidates = ['audio/webm;codecs=opus', 'audio/webm'];
        let mimeType = '';
        for (let i = 0; i < mimeCandidates.length; i++) {
          if (MediaRecorder.isTypeSupported(mimeCandidates[i])) { mimeType = mimeCandidates[i]; break; }
        }

        sttRecorder = mimeType ? new MediaRecorder(sttStream, { mimeType: mimeType }) : new MediaRecorder(sttStream);

        sttRecorder.ondataavailable = async function (e) {
          if (!e.data || e.data.size === 0) return;
          if (!sttWs || sttWs.readyState !== WebSocket.OPEN) return;
          const buf = await e.data.arrayBuffer();
          sttWs.send(buf);
        };

        sttRecorder.start(250);
      }

      async function stopStt() {
        if (!sttIsRunning) return;
        sttIsRunning = false;

        if (debounceTimer) { clearTimeout(debounceTimer); debounceTimer = null; }

        try { if (sttRecorder && sttRecorder.state !== 'inactive') sttRecorder.stop(); } catch (e) {}
        try { if (sttStream) sttStream.getTracks().forEach(function (t) { t.stop(); }); } catch (e) {}
        try { if (sttWs && sttWs.readyState === WebSocket.OPEN) sttWs.close(); } catch (e) {}

        sttRecorder = null;
        sttStream = null;
        sttWs = null;

        micBtn.classList.remove('active');
        micLabel.textContent = 'STT 시작';

        lastAnalysisBlock = '--- 분석 결과 ---\n(STT 중지됨)\n';
        setStatus('STT 중지됨', null);
        await renderHistoryPlusAnalysis();
      }

      micBtn.addEventListener('click', async function () {
        try {
          if (!sttIsRunning) await startStt();
          else await stopStt();
        } catch (e) {
          lastAnalysisBlock = '--- 분석 결과 ---\nSTT 시작 실패: ' + e.message + '\n';
          setStatus('STT 시작 실패: ' + e.message, false);
          await renderHistoryPlusAnalysis();
          try { await stopStt(); } catch (e2) {}
        }
      });

      setStatus('초기화 중... (서버 /history 확인)', null);
      renderHistoryPlusAnalysis();
      ctx.clearRect(0,0,canvas.width,canvas.height);
    });
  </script>
</body>
</html>